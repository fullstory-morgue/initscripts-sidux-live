#!/bin/bash
# Basic system configuration and hardware setup
# (C) Klaus Knopper <knopper@knopper.net> 2004
# (C) 2003-2006 Joerg Schirottke <master@kanotix.com>
# (C) 2005-2006 Stefan Lippers-Hollmann <s.l-h@gmx.de>

PATH="/bin:/sbin:/usr/bin:/usr/sbin"
export PATH

umask 022

# override tool behaviour through distro-defaults
FLL_DISTRO_MODE="installed"
FLL_IMAGE_DIR="SIDUX"
FLL_DISTRO_NAME="sidux"
FLL_MOUNTPOINT="/SIDUX"
FLL_LIVE_USER="sidux"
FLL_PERSISTENT_HOME="sidux.img"
FLL_WALLPAPER="/usr/share/wallpapers/sidux.jpg"

X_CONF="/etc/X11/xorg.conf"

[ -r /etc/default/distro ] && . /etc/default/distro

[ ! "$FLL_DISTRO_MODE" = "live" ] && exit 0

[ -z "$FLL_MOUNTPOINT" ] && FLL_MOUNTPOINT="/$FLL_IMAGE_DIR"

case "$1" in
	start)
		;;
	stop)
		;;
	restart|force-reload)
		;;
esac

# Ignore these signals: INT, TERM, SEGV
trap "" 2 3 11

###############################################################################
# ANSI COLORS
###############################################################################
CRE="
[K"
NORMAL="[0;39m"
# RED: Failure or error message
RED="[1;31m"
# GREEN: Success message
GREEN="[1;32m"
# YELLOW: Descriptions
YELLOW="[1;33m"
# BLUE: System messages
BLUE="[1;34m"
# MAGENTA: Found devices or drivers
MAGENTA="[1;35m"
# CYAN: Questions
CYAN="[1;36m"
# BOLD WHITE: Hint
WHITE="[1;37m"

# get rid of these as soon as possible
SPLASHY_PROGRESS_PIPE="/etc/sysconfig/progress"
HWSETUP_MAIN="/etc/sysconfig/knoppix"
HWSETUP_MOUSE="/etc/sysconfig/mouse"
HWSETUP_SERVICES="/etc/sysconfig/services"
HWSETUP_DESKTOP="/etc/sysconfig/desktop"
touch "$HWSETUP_SERVICES"

###############################################################################
# utility Functions
###############################################################################
# Simple shell grep
stringinfile()
{
	case "$(cat $2)" in
		*$1*)
			return 0
			;;
	esac

	return 1
}

# same for strings
stringinstring()
{
	case "$2" in 
		*$1*)
			return 0
			;;
	esac

	return 1
}

# Reread boot command line; echo last parameter's argument or return false.
getbootparam()
{
	stringinstring " $1=" "$CMDLINE" || return 1
	result="${CMDLINE##*$1=}"
	result="${result%%[ 	]*}"
	echo "$result"
	return 0
}

# Check boot commandline for specified option
checkbootparam()
{
	stringinstring " $1" "$CMDLINE"
	return "$?"
}

# Run debconf with errorhandling
set_debconf()
{
	[ -n "$1" ] || return
	if [ ! -w /SIDUX/var/cache/debconf/config.dat ]; then
		ps -ef | grep "config.dat" >> /var/log/debconf_error.log
	fi
	DEBCONF_DEBUG=developer echo "$1" | /usr/bin/debconf-set-selections
}

start_service()
{
	if [ -x /etc/init.d/$1 ]; then
		if [ -n "$2" ]; then
			RUNLEVEL="$2" /etc/init.d/$1 start
		else
			/etc/init.d/$1 start
		fi
		return $?
	fi

	return 1
}
### EOF utility functions

###############################################################################
#  mount critical virtual filesystems
###############################################################################
start_service mountkernfs.sh

# Read in boot parameters
[ -z "$CMDLINE" ] && CMDLINE=" $(< /proc/cmdline)"

# Check if we are in interactive startup mode
INTERACTIVE=""
stringinstring "BOOT_IMAGE=expert" "$CMDLINE" && INTERACTIVE="yes"

# Check if we want the config floppy
MYCONF=""
case "$CMDLINE" in
	*\ myconf*|*\ floppyconf*|*\ custom*|*\ config*)
		MYCONF="yes"
		;;
esac

if [ -n "$MYCONF" ]; then
	# Check for given config directory
	MYCONFDIR="$(getbootparam 'myconfig')"
	[ -n "$MYCONFDIR" ] || MYCONFDIR="$(getbootparam 'myconf')"
	[ -n "$MYCONFDIR" ] || MYCONFDIR="$(getbootparam 'floppyconfig')"
	[ -n "$MYCONFDIR" ] || MYCONFDIR="$(getbootparam 'floppyconf')"
	[ -n "$MYCONFDIR" ] || MYCONFDIR="$(getbootparam 'custom')"
	[ -n "$MYCONFDIR" ] || MYCONFDIR="$(getbootparam 'config')"
fi

###############################################################################
# localization
###############################################################################
# Allow language specification via commandline. The default language
# will be overridden via "lang=de" boot commandline
LANGUAGE="$(getbootparam lang 2>/dev/null)"
[ -n "$LANGUAGE" ] || LANGUAGE="de"

# The default language/keyboard to use. This CANNOT be autoprobed.
# Most of these variables will be used to generate the KDE defaults
case "$LANGUAGE" in
	de-utf8|de)
		# German version UTF-8
		#LANGUAGE="de_DE:de"
		LANG="de_DE.UTF-8"
		KEYTABLE="de-latin1-nodeadkeys"
		KDEKEYBOARDS="de,us"
		TZ="Europe/Berlin"
		CD_COUNTRY="German"
	;;
	au-utf8|au)
		## Australian version
		#LANGUAGE="en_AU:en"
		LANG="en_AU.UTF-8"
		KEYTABLE="us"
		KDEKEYBOARDS="us"
		TZ="Australia/Sydney"
		CD_COUNTRY="us_american"
		;;
	be-utf8|be)
		## Belgian version
		#LANGUAGE="be_BY:be"
		LANG="be_BY.UTF-8"
		KEYTABLE="be2-latin1"
		KDEKEYBOARDS="be,fr,us"
		TZ="Europe/Brussels"
		CD_COUNTRY="Belgian"
		;;
	bg-utf8|be)
		## Bulgarian version
		#LANGUAGE="bg_BG:bg"
		LANG="bg_BG.UTF-8"
		KEYTABLE="bg"
		KDEKEYBOARDS="bg,us"
		TZ="Europe/Sofia"
		CD_COUNTRY="Bulgarian"
		;;
	br-utf8|be)
		## Brazilian Version
		#LANGUAGE="pt_BR:pt"
		LANG="pt_BR.UTF-8"
		KEYTABLE="br-abnt2"
		KDEKEYBOARDS="br,us"
		TZ="America/Sao_Paulo"
		CD_COUNTRY="Brazilian"
		;;
	ch-utf8|ch)
		## Swiss version (basically de with some modifications)
		#LANGUAGE="de_CH:de"
		LANG="de_CH.UTF-8"
		KEYTABLE="sg-latin1"
		KDEKEYBOARDS="de_CH,de,fr,us"
		TZ="Europe/Zurich"
		CD_COUNTRY="Swiss-de"
		;;
	cn-utf8|cn)
		## Simplified Chinese version
		LANG="zh_CN.UTF-8"
		KEYTABLE="us"
		KDEKEYBOARDS="us"
		TZ="Asia/Shanghai"
		CD_COUNTRY=""
		;;
	cs-utf8|cz-utf8|cs|cz)
		## Czech version
		#LANGUAGE="cs_CZ:cs"
		LANG="cs_CZ.UTF-8"
		KEYTABLE="cz-lat2"
		KDEKEYBOARDS="cs,us"
		TZ="Europe/Prague"
		CD_COUNTRY="Czech-qwerty"
		;;
	dk-utf8|da-utf8|dk|da)
		## Dansk version
		LANG="da_DK.UTF-8"
		KEYTABLE="dk"
		KDEKEYBOARDS="dk,us"
		TZ="Europe/Copenhagen"
		CD_COUNTRY="Danish"
		;;
	el-utf8|el)
		## Greek version
		#LANGUAGE="el_GR:el"
		LANG="el_GR.UTF-8"
		KEYTABLE="gr"
		KDEKEYBOARDS="gr,us"
		TZ="Europe/Athens"
		CD_COUNTRY="Greek"
		;;
	es-utf8|es)
		## Spanish version
		#LANGUAGE="es_ES:es"
		LANG="es_ES.UTF-8"
		KEYTABLE="es"
		KDEKEYBOARDS="es,us"
		TZ="Europe/Madrid"
		CD_COUNTRY="Spanish"
		;;
	fi-utf8|fi)
		## Finnish version, though we may not have the kde-i18n files
		#LANGUAGE="fi_FI:fi"
		LANG="fi_FI.UTF-8"
		KEYTABLE="fi-latin1"
		KDEKEYBOARDS="fi,us"
		TZ="Europe/Helsinki"
		CD_COUNTRY="Swedish"
		;;
	fr-utf8|fr)
		## French version
		#LANGUAGE="fr_FR"
		LANG="fr_FR.UTF-8"
		KEYTABLE="fr"
		KDEKEYBOARDS="fr,us"
		TZ="Europe/Paris"
		CD_COUNTRY="French"
		;;
	ga-utf8|ga)
		## Irish Gaeilge version
		LANG="ga_IE.UTF-8"
		KEYTABLE="uk"
		KDEKYBOARDS="il"
		TZ="Europe/Dublin"
		CD_COUNTRY="British"
		;;
	he-utf8|il-utf8|he|il)
		## Hebrew version
		#LANGUAGE="he_IL:he"
		LANG="he_IL.UTF-8"
		KEYTABLE="us"
		KDEKEYBOARDS="il,us"
		TZ="Asia/Jerusalem"
		CD_COUNTRY="Hebrew"
		;;
	ie-utf8|ie)
		## Irish (English) version
		#LANGUAGE="en_IE:en"
		LANG="en_IE.UTF-8"
		KEYTABLE="uk"
		KDEKEYBOARDS="ie,gb,us"
		TZ="Europe/Dublin"
		CD_COUNTRY="British"
		;;
	it-utf8|it)
		## Italian version
		#LANGUAGE="it_IT"
		LANG="it_IT.UTF-8"
		KEYTABLE="it"
		KDEKEYBOARDS="it,us"
		TZ="Europe/Rome"
		CD_COUNTRY="Italian"
		;;
	ja-utf8|ja)
		## (limited) Japanese version
		#LANGUAGE="ja_JP:ja"
		LANG="ja_JP.UTF-8"
		KEYTABLE="us"
		KDEKEYBOARDS="jp,us"
		TZ="Asia/Tokyo"
		CD_COUNTRY="Japanese"
		;;
	nl-utf8|nl)
		## Dutch version
		#LANGUAGE="nl_NL:nl"
		LANG="nl_NL.UTF-8"
		KEYTABLE="us"
		KDEKEYBOARDS="nl,us"
		TZ="Europe/Amsterdam"
		CD_COUNTRY="Dutch"
		;;
	pl-utf8|pl)
		## Polish version
		#LANGUAGE="pl_PL:pl"
		LANG="pl_PL.UTF-8"
		KEYTABLE="pl"
		KDEKEYBOARDS="pl,us"
		TZ="Europe/Warsaw"
		CD_COUNTRY="Polish"
		;;
	pt-utf8|pl)
		## Portuguese version
		#LANGUAGE="pt_PT:pt"
		LANG="pt_PT.UTF-8"
		KEYTABLE="pt-latin1"
		KDEKEYBOARDS="pt,us"
		TZ="Europe/Lisbon"
		CD_COUNTRY="Portugese"
		;;
	ru-utf8|ru)
		## Russian version
		#LANGUAGE="ru_RU:ru"
		LANG="ru_RU.UTF-8"
		KEYTABLE="ru"
		KDEKEYBOARDS="ru,us"
		TZ="Europe/Moscow"
		CD_COUNTRY="Russian"
		;;
	sk-utf8|sk)
		## Slovak version (guessed)
		#LANGUAGE="sk_SK:sk"
		LANG="sk_SK.UTF-8"
		KEYTABLE="sk-qwerty"
		KDEKEYBOARDS="sk,us"
		TZ="Europe/Bratislava"
		CD_COUNTRY="Slovak-qwerty"
		;;
	sl-utf8|sl)
		## Slovenian keyboard
		#LANGUAGE="sl_SI:sl"
		LANG="sl_SI.UTF-8"
		KEYTABLE="slovene"
		KDEKEYBOARDS="si,us"
		TZ="Europe/Ljubljana"
		#CONSOLEFONT="iso02g"
		CD_COUNTRY="Slovene"
		;;
	tr-utf8|tr)
		## Turkish version (guessed)
		#LANGUAGE="tr_TR"
		LANG="tr_TR.UTF-8"
		KEYTABLE="tr_q-latin5"
		KDEKEYBOARDS="tr,us"
		TZ="Europe/Istanbul"
		CD_COUNTRY="Turkish"
		;;
	tw-utf8|tw)
		## Traditional Chinese version (thanks to Chung-Yen Chang)
		#LANGUAGE="zh_TW:zh"
		LANG="zh_TW.UTF-8"
		KEYTABLE="us"
		KDEKEYBOARDS="us"
		TZ="Asia/Taipei"
		CD_COUNTRY=""
		;;
	uk-utf8|uk)
		## British version UTF-8
		#LANGUAGE="en_GB:en"
		LANG="en_GB.UTF-8"
		KEYTABLE="uk"
		KDEKEYBOARDS="gb,us"
		TZ="Europe/London"
		CD_COUNTRY="British"
		;;
	us-utf8|us)
		# American version UTF-8
		#LANGUAGE="en_US:en"
		LANG="en_US.UTF-8"
		KEYTABLE="us"
		KDEKEYBOARDS="us,ca"
		TZ="America/New_York"
		CD_COUNTRY="us_american"
		;;
	*)
		# American version UTF-8
		#LANGUAGE="en_US:en"
		LANG="en_US.UTF-8"
		KEYTABLE="us"
		KDEKEYBOARDS="us,ca"
		TZ="Europe/London"
		CD_COUNTRY="us_american"
		;;
esac

export LANG

###############################################################################
# update locale settings
###############################################################################
# ensure that /etc/default/locale is an ordinary file and not a symlink
rm -f /etc/default/locale
# write locale
update-locale "LANG=$LANG"
# install keymap
/usr/sbin/install-keymap "$KEYTABLE" &

###############################################################################
# for console-data
###############################################################################
case $CD_COUNTRY in
	French)
		#Issue
		CD_FAMILY="azerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Same as X11 (latin 9)"
		CD_FULL="$CD_COUNTRY"
		;;
	Belgian)
		CD_FAMILY="azerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	us_american)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="US american"
		;;
	British)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Bulgarian)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Byelorussian)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Brazilian)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Canadian)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="English"
		CD_FULL="$CD_COUNTRY"
		;;
	Canadian-fr)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="French"
		CD_FULL="$CD_COUNTRY"
		;;
	Czech-qwerty)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Danish)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Spanish)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Estonian)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Finnish)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Polish)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Greek)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Italian)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Lithuanian)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Latvian)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Norwegian)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Japanese)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Dutch)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Hebrew)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Hungarian)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Icelandic)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Latin_American)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="Latin American"
		;;
	Macedonian)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Portugese)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Romanian)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Russian)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Serbian-qwerty)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Swedish)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Slovak-qwerty)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Thai)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Turkish)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Ukrainian)
		CD_FAMILY="qwerty"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Swiss-fr)
		CD_FAMILY="qwertz"
		CD_KEYMAP="Standard"
		CD_VARIANT="French"
		CD_FULL="$CD_COUNTRY"
		;;
	Swiss-de)
		CD_FAMILY="qwertz"
		CD_KEYMAP="Standard"
		CD_VARIANT="German"
		CD_FULL="German"
		;;
	German)
		CD_FAMILY="qwertz"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Slovak-qwertz)
		CD_FAMILY="qwertz"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Czech-qwertz)
		CD_FAMILY="qwertz"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Hungarian)
		CD_FAMILY="qwertz"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Slovene)
		CD_FAMILY="qwertz"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Croat)
		CD_FAMILY="qwertz"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	Serbian-qwertz)
		CD_FAMILY="qwertz"
		CD_KEYMAP="Standard"
		CD_VARIANT="Standard"
		CD_FULL="$CD_COUNTRY"
		;;
	*)
		CD_FAMILY="qwerty"
		CD_KEYMAP="us"
		CD_VARIANT="Standard"
		CD_FULL="US american"
		;;
esac

CD_LAYOUT="$(echo $CD_COUNTRY | cut -d'-' -f1)"
CD_LAYOUT_PATH=$(echo $CD_COUNTRY | tr [A-Z] [a-z] | cut -d'-' -f1)
CD_FULL_FIX="$(echo $CD_FULL | cut -d'-' -f1)"
CD_VARIANT_PATH="$(echo $CD_VARIANT | tr [A-Z] [a-z])"

###############################################################################
# enable splash if possible
###############################################################################
SPLASH=$(getbootparam "splash" 2>/dev/null)
[ -z "$SPLASH" ] && checkbootparam "splash" && SPLASH=on
[ "$SPLASH" = "off" ] && SPLASH=""

if [ -n "$SPLASH" ]; then
	RES=$(fbresolution 2>/dev/null)
	[ -z "$RES" ] && RES=1024x768
	if [ "$RES" = "1024x768" -o "$RES" = "800x600" ] && [ -x /sbin/splashy ]; then
		[ -p /etc/splashy/splashy.fifo ] || /sbin/splashy boot
	fi
fi

update_progress()
{
	# be sure we are non-blocking
	if [ -p /etc/splashy/splashy.fifo ]; then
		(echo "progress $1" > /etc/splashy/splashy.fifo) &
	fi
}

# / must be read-write in any case, starting from here
mount -o remount,rw / 2>/dev/null

# Delete obsolete links and files before starting autoconfig
if ! checkbootparam "nohwsetup"; then
	rm -f	/dev/cdrom* /dev/cdwriter* /dev/dvdwriter* /dev/mouse* /dev/modem* /dev/scanner* \
		"$HWSETUP_I18N" "$HWSETUP_KEYBOARD" "$HWSETUP_MAIN" \
		2>/dev/null
fi

# Also read desired desktop, if any
DESKTOP="$(getbootparam desktop 2>/dev/null)"
# Allow only supported windowmanagers
case "$DESKTOP" in
	gnome|enlightenment|kde|larswm|xfce|xfce4|windowmaker|wmaker|icewm|fluxbox|twm|nx|rdp|kiosk)
		;;
	*)
		DESKTOP="kde"
		;;
esac

# Desired desktop
echo "DESKTOP=\"$DESKTOP\""            > "$HWSETUP_DESKTOP"

# override dpi setting
CUSTOM_DPI="$(getbootparam dpi 2>/dev/null)"

# Write DPI setting if specified
[ "$CUSTOM_DPI" ] && echo "CUSTOM_DPI=\"$CUSTOM_DPI\""  >> "$HWSETUP_MAIN"

# disable 915resolution hack
checkbootparam "no915res" && echo "NO915RES=\"yes\"" >> "$HWSETUP_MAIN"

# Set KDE i18n Keyboard
if grep -q ^KDEKEYBOARDS /etc/default/distro 2>/dev/null; then
	sed -i -e 's/^FLL_KDEKEYBOARDS=.*$/FLL_KDEKEYBOARDS='"$KDEKEYBOARDS"'/' \
			/etc/default/distro
else
	echo "" >> /etc/default/distro
	echo "# kde i18n settings" >> /etc/default/distro
	echo "FLL_KDEKEYBOARDS=\"$KDEKEYBOARDS\"" >> /etc/default/distro
fi

# CD Checker
if checkbootparam "testcd" || checkbootparam "testdvd"; then
	echo " ${BLUE}Checking CD data integrity as requested by '${CYAN}testcd${BLUE}' boot option.${NORMAL}"
	echo " ${BLUE}Reading files and checking against ${FLL_IMAGE_DIR}/md5sums, this may take a while...${NORMAL}"
	echo -n "${RED}"
	( cd /cdrom/ ; rm -f /tmp/md5sum.log ; LANG="$LANG" md5sum -c ${FLL_IMAGE_DIR}/md5sums 2>&1 | tee /tmp/md5sum.log )
	if [ "$?" = "0" ]; then
		echo " ${GREEN}Everything looks OK${NORMAL}"
	else
		echo "${RED} *** CHECKSUM FAILED FOR THESE FILES:                          ***"
		egrep -v '(^md5sum:|OK$)' /tmp/md5sum.log
		echo "${RED} *** DATA ON YOUR CD MEDIUM IS POSSIBLY INCOMPLETE OR DAMAGED, ***${NORMAL}"
		echo "${RED} *** OR YOUR COMPUTER HAS BAD RAM.                             ***${NORMAL}"
		echo -n "${CYAN}Hit return to contine, or press the reset button to quit.${NORMAL} "
		read a
	fi
fi

update_progress 10

###############################################################################
# begin hardware detection and autoconfiguration
###############################################################################
echo " ${GREEN}Enabling ${YELLOW}udev${GREEN}.${NORMAL}"

# No kernel messages while probing modules
echo "0" > /proc/sys/kernel/printk

# start udev and mount special filesystems under /dev
start_service udev S
start_service mountdevsubfs.sh
start_service udev-mtab S

###############################################################################
# usbcore workaround
###############################################################################
# check if usbcore is not already loaded and allow some grace time
if ! stringinfile "usbcore" /proc/modules; then
	USBCORE_TIMEOUT="$(getbootparam usbwait 2>/dev/null)"
	[ -z "$USBCORE_TIMEOUT" ] && USBCORE_TIMEOUT=5
	USBCORE_TIMEOUT=$((USBCORE_TIMEOUT))
	[ $USBCORE_TIMEOUT -lt 0 -o $USBCORE_TIMEOUT -gt 60 ] && USBCORE_TIMEOUT=5

	echo -n "${BLUE}Waiting for ${YELLOW}usbcore${BLUE}. ${NORMAL}"
	
	for x in $(seq ${USBCORE_TIMEOUT}); do
		stringinfile "usbcore" /proc/modules && break
		echo -n "${BLUE}$((${USBCORE_TIMEOUT}-${x})) s${NORMAL}"
		for y in $(seq 10); do
			stringinfile "usbcore" /proc/modules && break
			sleep 0.1
		done
		for z in $(seq $((${#x}+2))); do echo -ne "\b \b"; done
	done

	if stringinfile "usbcore" /proc/modules; then
		echo "${GREEN}Done.${NORMAL}"
	else
		echo "${RED}Timeout reached.${NORMAL}"
	fi
fi

# mount usbfs
if stringinfile "usbcore" /proc/modules && ! stringinfile "/proc/bus/usb" /proc/mounts; then
	mount -o devmode=0666 -t usbfs /proc/bus/usb /proc/bus/usb 2>/dev/null || \
		echo "${RED}Unable to mount usbfs on /proc/bus/usb.${NORMAL}"
fi

###############################################################################
# setup console-data (before interactive setup stage)
###############################################################################
echo "${BLUE}Writing default settings for ${CYAN}console-data${NORMAL}"
set_debconf "locales locales/default_environment_locale select $LANG \
console-data console-data/keymap/policy select Select keymap from arch list \
console-data console-data/keymap/family select $CD_FAMILY \
console-data console-data/keymap/$CD_FAMILY/layout select $CD_FULL_FIX \
console-data console-data/keymap/$CD_FAMILY/$CD_LAYOUT_PATH/variant select $CD_VARIANT \
console-data console-data/keymap/$CD_FAMILY/$CD_LAYOUT_PATH/$CD_VARIANT_PATH/keymap select $CD_KEYMAP \
console-data console-data/keymap/full select $CD_FULL"

# put the console in Unicode mode
unicode_start 2>/dev/null

###############################################################################
# setup localhost
###############################################################################
# set hostname
start_service hostname.sh >/dev/null || hostname "$FLL_DISTRO_NAME"

# ensure ifup down has an ifstate file to write to
if start_service ifupdown >/dev/null; then
	# Bring up loopback interface now
	ifup lo
else
	ifconfig lo 127.0.0.1 up
fi

# Set clock (Local time is more often used than GMT, so it is default)
UTC=""
checkbootparam utc >/dev/null 2>&1 && UTC="-u"
checkbootparam gmt >/dev/null 2>&1 && UTC="-u"

# hwclock uses the TZ variable
KTZ="$(getbootparam tz 2>/dev/null)"
[ -f "/usr/share/zoneinfo/$KTZ" ] && [ -n "$KTZ" ] && TZ="$KTZ"
export TZ
hwclock $UTC -s

if [ -n "$TZ" ]; then
	rm -f /etc/localtime
	cp "/usr/share/zoneinfo/$TZ" /etc/localtime
	rm -f /etc/timezone
	echo "$TZ" > /etc/timezone
fi

update_progress 20

###############################################################################
# pcmcia/cardbus autoconfiguration
###############################################################################
# This needs to be done before other modules are being loaded by hwsetup
if checkbootparam "nopcmcia"; then
	echo " ${BLUE}Skipping PCMCIA detection as requested on boot commandline.${NORMAL}"
else
	# Try Cardbus or normal PCMCIA socket drivers
	modprobe yenta_socket	>/dev/null 2>&1 || \
	modprobe i82365		>/dev/null 2>&1 || \
	modprobe tcic		>/dev/null 2>&1

	if [ "$?" = "0" ]; then
		if start_service pcmciautils >/dev/null; then
			echo " ${GREEN}PCMCIA started.${NORMAL}"
			sleep 4
		fi
	fi
fi

update_progress 40
# Second: Search & configure supported hardware
# Check for options relevant to hwsetup
NOSERIAL=""
checkbootparam noserial >/dev/null 2>&1 && NOSERIAL="yes"
[ -n "$NOSERIAL" ] && HWSETUP_NOSERIAL="-m"
# load serial module
modprobe 8250 >/dev/null 2>&1

# load psmouse module
modprobe psmouse >/dev/null 2>&1
echo -n "${WHITE}"
if hwsetup $HWSETUP_NOSERIAL >/dev/null; then
	echo -n "${NORMAL}"
else
	echo " ${RED}Please check.${NORMAL}"
fi
update_progress 60

# activate PC Speaker
modprobe pcspkr >/dev/null 2>&1

# activate input driver for char event devices
modprobe evdev >/dev/null 2>&1

# Handle special options for ALSA sound drivers
rm -f /etc/modprobe.d/alsa-special
SYS=$(cut -f2 -d: /sys/devices/pci*/{,*/}*/modalias 2>/dev/null)
ALSA_SPECIAL=""
for sysid in $SYS; do
	# ALSA_SPECIAL is [kernel module with _ not -] [needed options]
	case "$sysid" in
		v000010DEd0000026Csv00001043sd000081CBbc*)
			# ASUS M2NPV-VM
			ALSA_SPECIAL="snd_hda_intel position_fix=1 model=3stack"
			break
			;;
		v00008086d000027D8sv00001854sd0000005Fbc*)
			# LG Electronics P1-J302E1
			ALSA_SPECIAL="snd_hda_intel model=lg"
			break
			;;
		v00008086d0000284Bsv00008086sd0000284Bbc*)
			# MSI MS-7235
			ALSA_SPECIAL="snd_hda_intel position_fix=1"
			break
			;;
	esac
done
if [ -n "$ALSA_SPECIAL" ]; then
	echo options $ALSA_SPECIAL > /etc/modprobe.d/alsa-special
	if [ -d /sys/module/${ALSA_SPECIAL%% *} ]; then
		rmmod ${ALSA_SPECIAL%% *}
		modprobe $ALSA_SPECIAL
	fi
fi

# Read in what hwsetup has found
[ -f "$HWSETUP_MAIN" ] && . "$HWSETUP_MAIN"

# Workaround for new mouse detection
if [ -f "$HWSETUP_MOUSE" ]; then
	. "$HWSETUP_MOUSE"
	if [ "$MOUSETYPE" = "ps2" ]; then
		ln -sf /dev/psaux /dev/mouse
		perl -pi -e "s|/dev/input/mice|/dev/psaux|" "$HWSETUP_MOUSE" "$HWSETUP_MAIN"
		. "$HWSETUP_MOUSE"
		. "$HWSETUP_MAIN"
	fi
fi
       
# Mouse
if [ -n "$MOUSE_DEVICE" ]; then
	echo " ${GREEN}Mouse is ${YELLOW}${MOUSE_FULLNAME}${GREEN} at ${MAGENTA}${MOUSE_DEVICE}${NORMAL}"
fi

# Soundcard
if [ -n "$SOUND_FULLNAME" -o -n "$SOUND_DRIVER" ]; then
	SOUNDCARD="$SOUND_DRIVER"
	echo -n " ${GREEN}Soundcard is"
	[ -n "$SOUND_FULLNAME" ] && echo -n " ${YELLOW}$SOUND_FULLNAME${GREEN}"
	[ -n "$SOUNDCARD" ] && echo -n " (${MAGENTA}$SOUNDCARD${GREEN})"
	echo "${NORMAL}"
fi

# Get max. sound volume
VOL="$(getbootparam vol 2>/dev/null)"
[ -z "$VOL" ] && VOL=50
VOL=$((VOL))
[ $VOL -lt 0 -o $VOL -gt 100 ] && VOL=50

# Fast ALSA detection
if [[ "$SOUND_DRIVER" = snd-* ]]; then
	echo alias snd-card-0 $SOUND_DRIVER > /etc/modprobe.d/sound
	echo options $SOUND_DRIVER index=0 >> /etc/modprobe.d/sound
	#set_mixers
	aumix -m 0 -v $VOL -w $VOL -c $VOL >/dev/null 2>&1 # set pcm & master & cd to $VOL, micro to 0
fi

###############################################################################
# misc. hardware detections/workarounds
###############################################################################
# dwl520e1 detection
if lspci -nv|grep 1260:3873 -A1|grep -q 1186:3700; then
	/usr/sbin/dwl520e1_fw_load >/dev/null 2>&1
	echo 'install hostap_pci /sbin/modprobe --ignore-install hostap_pci && /usr/sbin/dwl520e1_fw_load >/dev/null 2>&1' > \
		/etc/modprobe.d/dwl520e1
fi

# ipw3945 detection
if [ -e /sys/bus/pci/drivers/ipw3945/*/cmd ]; then
	start_service ipw3945d >/dev/null
fi

# soft modem detection
if ! checkbootparam "nomodem"; then
	if lspci|grep Intel|grep -q "AC'97 Modem Controller"; then
		if start_service sl-modem-daemon >/dev/null; then
			grep -q ^sl-modem-daemon "$HWSETUP_SERVICES" >/dev/null || echo sl-modem-daemon >> "$HWSETUP_SERVICES"
		fi
	fi
fi

# Start FC detection on vt10
NOFC=""
if [ -x /usr/sbin/detect-fc ]; then
	checkbootparam "nofc" && NOFC="yes"
	[ -e /etc/drdsl/modules.inc ] && NOFC="yes"
	if [ -z "$NOFC" ]; then
		echo " ${GREEN}Starting ${YELLOW}FC${GREEN} detection on ${YELLOW}vt10${GREEN}.${NORMAL}"
		open -c 10 /usr/sbin/detect-fc
	fi
fi

###############################################################################
# load required modules
###############################################################################
# Load fuse module
modprobe fuse >/dev/null 2>&1

# load capability LSM (needed for hal)
modprobe capability >/dev/null 2>&1

###############################################################################
# Check for blind option or brltty
###############################################################################
BLIND=""
checkbootparam "blind" && BLIND="yes"
BRLTTY="$(getbootparam brltty 2>/dev/null)"

if [ -n "$BLIND" -o -n "$BRLTTY" ]; then
	if [ -x /sbin/brltty ]; then
		# Blind option detected, start brltty now.
		CMD=brltty
		BRLTYPE=""
		BRLDEV=""
		BRLTEXT=""
		if [ -n "$BRLTTY" ]; then
			# Extra options
			BRLTYPE="${BRLTTY%%,*}"
			R="${BRLTTY#*,}"
			if [ -n "$R" -a "$R" != "$BRLTTY" ]; then
				BRLTTY="$R"
				BRLDEV="${BRLTTY%%,*}"
				R="${BRLTTY#*,}"
				if [ -n "$R" -a "$R" != "$BRLTTY" ]; then
					BRLTTY="$R"
					BRLTEXT="${BRLTTY%%,*}"
					R="${BRLTTY#*,}"
				fi
			fi
		fi
		[ -n "$BRLTYPE" ] && CMD="$CMD -b $BRLTYPE"
		[ -n "$BRLDEV" ] && CMD="$CMD -d $BRLDEV"
		[ -n "$BRLTEXT" ] && CMD="$CMD -t $BRLTEXT"
		echo " ${BLUE}Starting braille-display manager: ${GREEN}${CMD}${BLUE}.${NORMAL}"
		( exec $CMD & )
		sleep 2
	fi
fi

###############################################################################
# INTERACTIVE II
###############################################################################
if [ -n "$INTERACTIVE" ]; then
	# Interactive configuration
	echo "${BLUE}Entering interactive configuration second stage.${NORMAL}"

	echo " ${GREEN}Your console keyboard defaults to: ${MAGENTA}${KEYTABLE}"
	echo -n "${CYAN}Do you want to (re)configure your console keyboard?${NORMAL} [Y/n] "
	read a
	[ "$a" != "n" ] && /usr/sbin/kbdconfig
	# kbdconfig already loads the keyboard if modified.

	echo -n "${CYAN}Do you want to (re)configure your soundcard?${NORMAL} [Y/n] "
	read a
	[ "$a" != "n" ] && sndconfig && ( exec aumix -m 0 >/dev/null 2>&1 & )

	if [ -n "$MOUSE_FULLNAME" -o -n "$MOUSE_DEVICE" ]; then
		echo -n " ${GREEN}Your mouse has been autodetected as: ${MAGENTA}"
		ls -l /dev/mouse | awk '{print $9 " " $10 " " $11}'
		echo -n "${NORMAL}"
	fi

	echo -n "${CYAN}Do you want to (re)configure your mouse?${NORMAL} [Y/n] "
	read a
	[ -f "$HWSETUP_MOUSE" ] && . "$HWSETUP_MOUSE"
	[ "$a" != "n" ] && mouseconfig
fi

update_progress 80

###############################################################################
# automatic X Setup
###############################################################################
if ! checkbootparam "nomkxf86config"; then
	[ -x /usr/sbin/mkxf86config ] && /usr/sbin/mkxf86config
fi

# Read in changes
[ -f "$HWSETUP_MAIN" ] && . "$HWSETUP_MAIN"

###############################################################################
# INTERACTIVE III
###############################################################################
if [ -n "$INTERACTIVE" ]; then
	echo -n "${CYAN}Do you want to (re)configure your graphics (X11) subsystem?${NORMAL} [Y/n] "
	read a
	[ "$a" != "n" ] && xf86cfg -textmode -xf86config "$X_CONF" >/dev/console 2>&1 </dev/console
	echo " ${GREEN}Interactive configuration finished. Everything else should be fine for now.${NORMAL}"
fi

if [ -n "$USE_ALSA" -a -x /etc/init.d/alsa-autoconfig ]; then
	[ -n "$SOUND_DRIVER" ] && rmmod -r "$SOUND_DRIVER" >/dev/null 2>&1
	# Export ALSA_CARD cariable to init script
	case "$ALSA_CARD" in
		auto*)
		ALSA_CARD=""
		;;
	esac
	ALSA_CARD="$ALSA_CARD" /etc/init.d/alsa-autoconfig
	# Something went wrong ?
	[ ! -r /etc/modules.conf ] && ln -sf /${FLL_MOUNTPOINT}/etc/modules.conf /etc/modules.conf
fi

RUNLEVEL="$(runlevel)"

###############################################################################
# partition detection and autoconfiguration
###############################################################################
# Add cdrom devices to /etc/fstab
for c in $(ls -d /dev/cdrom* 2>/dev/null); do
	m=${c#/dev}
	[ "$m" = "/cdrom" ] && m="/cdrom0"
	[ -d /media$m ] || mkdir -p /media$m 
	#stringinfile "$c" "/etc/fstab" || printf "%-15s %-15s %-7s %-15s %-7s %s\n" "$c" "/media$m" "udf,iso9660" "user,noauto" "0" "0" >> /etc/fstab
	stringinfile "/dev/$(readlink $c)" "/etc/fstab" || printf "%-15s %-15s %-7s %-15s %-7s %s\n" "/dev/$(readlink $c)" "/media$m" "udf,iso9660" "user,noauto" "0" "0" >> /etc/fstab
done

# Add floppy devices to /etc/fstab
for f in $(ls -d /sys/block/fd* 2>/dev/null); do
	[ -d /media/floppy${f#/sys/block/fd} ] || mkdir -p /media/floppy${f#/sys/block/fd} 
	stringinfile "$f" "/etc/fstab" || printf "%-15s %-15s %-7s %-15s %-7s %s\n" "/dev${f#/sys/block}" "/media/floppy${f#/sys/block/fd}" "auto" "rw,user,noauto" "0" "0" >> /etc/fstab
done

NOSWAP=""
checkbootparam "noswap" && NOSWAP="yes"

# Collect partitions from /proc/partitions
partitions=""
while read major minor blocks partition relax; do
	partition="${partition##*/}"
	[ -z "$partition" -o ! -e "/dev/$partition" ] && continue
	case "$partition" in
		hd?)
			# IDE Harddisk, entire disk
			;;
		sd?)
			# SCSI Harddisk, entire disk
			;;
		[hs]d*)
			# IDE or SCSI disk partition
			partitions="$partitions /dev/$partition"
			;;
	esac
done <<EOT
$(awk 'BEGIN{old="__start"}{if($0==old){exit}else{old=$0;if($4&&$4!="name"){print $0}}}' /proc/partitions)
EOT

# Disable DMA for all IDE drives now if not enabled (and if not already done by linuxrc).
# This is already done by linuxrc now.
# However, for a harddisk-installed version, we are doing it again here.
if checkbootparam "nodma"; then
	for d in $(cd /proc/ide 2>/dev/null && echo hd[a-z]); do
		if test -d /proc/ide/$d; then
			if egrep -q 'using_dma[ \t]+1' /proc/ide/$d/settings 2>/dev/null; then
				MODEL="$(cat /proc/ide/$d/model 2>/dev/null)"
				test -z "$MODEL" && MODEL="[GENERIC IDE DEVICE]"
				echo "${BLUE}Disabling DMA acceleration for: ${MAGENTA}$d 	${YELLOW}[${MODEL}]${NORMAL}"
				echo "using_dma:0" >/proc/ide/$d/settings
			fi
		fi
	done
fi

###############################################################################
# create fstab and populate /media
###############################################################################
# Start creating /etc/fstab with HD partitions and USB SCSI devices now
if checkbootparam "nofstab"; then
	echo " ${BLUE}Skipping /etc/fstab creation as requested on boot commandline.${NORMAL}"
else
	echo -n "${BLUE}Scanning for Harddisk partitions and creating ${YELLOW}/etc/fstab${BLUE}... "
	[ -d /${FLL_MOUNTPOINT} ] && rebuildfstab -r -u ${FLL_LIVE_USER} -g $(getent passwd "$FLL_LIVE_USER" | cut -d\: -f 4) >/dev/null 2>/dev/null || rebuildfstab -r >/dev/null 2>&1
	if [ -e /var/run/rebuildfstab.pid ]; then
		# Another instance of rebuildfstab, probably from hotplug, is still running, so just wait.
		sleep 8
	fi
	echo "${GREEN}Done.${NORMAL}"
fi

if [ -n "$partitions" ]; then
	while read p m f relax; do
		case "$p" in
			*fd0*|*proc*|*pts*|*sys*|*cdrom*|\#*)
			continue
			;;
		esac
		options="users,exec"
		fnew=""
		case "$f" in
			swap)
				if [ -n "$NOSWAP" ]; then
					echo "${BLUE}Ignoring swap partition ${MAGENTA}$p${BLUE} as requested.${NORMAL}"
				else
					echo "${BLUE}Using swap partition ${MAGENTA}$p${BLUE}.${NORMAL}"
					swapon $p 2>/dev/null
				fi
				continue
			;;
		esac
		# Create mountdir if not already present
		d="/media/${p##*/}" ; [ -d "$d" ] || mkdir -p "$d"
		case "$f" in
			vfat|msdos)
				if [ -z "$NOSWAP" ] && mount -o uid=${FLL_LIVE_USER},gid=$(getent passwd "$FLL_LIVE_USER" | cut -d\: -f 4),ro -t $f $p $d 2>/dev/null; then
					if [ -f $d/${FLL_DISTRO_NAME}.swp ]; then
						mount -o remount,rw $d
						if swapon $d/${FLL_DISTRO_NAME}.swp 2>/dev/null; then
							echo "${BLUE}Using ${FLL_DISTRO_NAME} swapfile ${MAGENTA}$d/${FLL_DISTRO_NAME}.swp${BLUE}.${NORMAL}"
							mount -o remount,ro $d 2>/dev/null
							fnew="$d/${FLL_DISTRO_NAME}.swp none            swap    sw              0       0"
							stringinfile "$fnew" "/etc/fstab" || echo "$fnew" >> /etc/fstab
						else
							umount $d
						fi
					else
						umount $d
					fi
				fi
				;;
		esac
	done <<EOT
$(cat /etc/fstab)
EOT
fi
update_progress 90

###############################################################################
# interactively create swapfiles on DOS partitions (if necessary and possible)
###############################################################################
FREEMEM="$(awk 'BEGIN{m=0};/MemFree|Cached|SwapFree/{m+=$2};END{print m}' /proc/meminfo)"

if [ "$FREEMEM" -lt 80000 -a -x /usr/bin/kdeinit -a -x /usr/sbin/mkdosswapfile ]; then
	case "$LANG" in
		de*)
			LOWMEM="Ihr Rechner verfÃ¼gt nur Ã¼ber ${FREEMEM}kB freien RAM-Speicher. Dies ist fÃ¼r das Arbeiten mit Linux zwar generell ausreichend, aber leider nicht genug, um grÃ¶ÃŸere Anwendungen wie KDE oder Office-Pakete zu starten. Sie kÃ¶nnen im nÃ¤chsten Schritt versuchen, eine sog. Auslagerungsdatei auf einer DOS-Partition (sofern vorhanden) einzurichten."
			;;
		*)
			LOWMEM="There are only ${FREEMEM}kB of RAM available in your computer. While this is usually sufficient for working under Linux, it is unfortunately not enough for starting bigger applications like KDE, or office suites. You can try to create a so-called swapfile on an existing DOS-Partition (if available) in the next step."
			;;
	esac
		dialog --msgbox "$LOWMEM" 12 65 </dev/console >/dev/console 2>&1 
		/usr/sbin/mkdosswapfile </dev/console >/dev/console 2>&1 
fi

###############################################################################
# Fat-Client-Version: DHCP Broadcast for IP address
###############################################################################
if checkbootparam "nodhcp"; then
	echo " ${BLUE}Skipping DHCP broadcast/network detection as requested on boot commandline.${NORMAL}"
else
	NETDEVICES="$(perl -e 'print($_,"\n") for map {s/.*\///; grep( /^(eth|ath|wlan|ra|tr)\d*$/,$_);} </sys/class/net/*>' 2>/dev/null)"
	if [ -n "$NETDEVICES" ]; then
		CONNETDEVS=""
		for DEVICE in $NETDEVICES; do
			if ifconfig "$DEVICE" up; then
				sleep 1
				
				# probe for link beat
				ifplugstatus --quiet "$DEVICE"
			
				# link beat detected ?
				if [ "$?" = "2" ]; then
					CONNETDEVS="$CONNETDEVS $DEVICE"
					echo "" 			>> /etc/network/interfaces
					echo "auto $DEVICE" 		>> /etc/network/interfaces
					echo "iface $DEVICE inet dhcp" 	>> /etc/network/interfaces
				else
					ifconfig "$DEVICE" down
				fi
			fi
		done
		
		if [ -n "$CONNETDEVS" ]; then
			echo " ${GREEN}Enabling DHCP broadcast for IP on connected ethernet devices:${NORMAL}${MAGENTA}${CONNETDEVS}${GREEN}.${NORMAL}"
			( ifup -a >/dev/null 2>&1 ) &
		fi
	fi
fi

if [ -r "${FLL_WALLPAPER}" ]; then
	# Set $BACKGROUND according to distro defaults
	BACKGROUND="${FLL_WALLPAPER}"
else
	# Search for custom background image for KDE/GNOME/X
	for i in /cdrom/${FLL_IMAGE_DIR}/background /usr/share/wallpapers/sidux; do
		for j in png jpg gif; do
			BACKGROUND="$i.$j"
			[ -e "$BACKGROUND" ] && break 2
		done
	done
fi
echo 'BACKGROUND="'"$BACKGROUND"'"' >> "$HWSETUP_MAIN"

###############################################################################
# utility functions for perstent config/home handling below
###############################################################################
findfile()
{
	FOUND=""
	# search all partitions for a file in the root directory
	for i in /media/[sh]d[a-z] /media/[sh]d[a-z][1-9] /media/[sh]d[a-z][1-9]?*; do
		# See if it's already mounted
		[ -f "$i/$1" ] &&  { echo "$i/$1"; return 0; }
		if [ -d "$i" ] && mount -r "$i" 2>/dev/null; then
			[ -f "$i/$1" ] && FOUND="$i/$1"
			umount -l "$i" 2>/dev/null
			[ -n "$FOUND" ] && { echo "$FOUND"; return 0; }
		fi
	done
	return 2
}

# Load aes and cryptoloop
modprobe aes 2>/dev/null
modprobe cryptoloop 2>/dev/null

# Try to mount this filesystem read-only, without or with encryption
trymount()
{
	# Check if already mounted
	case "$(cat /proc/mounts)" in
		*\ $2\ *)
			return 0
			;;
	esac

	# Apparently, mount-aes DOES autodetect AES loopback files.
	[ -b "$1" ] && { mount -t auto -o ro "$1" "$2" 2>/dev/null; RC="$?"; }

	# We need to mount crypto-loop files with initial rw support
	[ -f "$1" ] && { mount -t auto -o loop,rw "$1" "$2" 2>/dev/null; RC="$?"; }
	# Mount succeeded?
	[ "$RC" = "0" ] && return 0
	echo ""
	echo "${CYAN}Filesystem not autodetected, trying to mount $1 with AES256 encryption${NORMAL}"
	a="y"
	while [ "$a" != "n" -a "$a" != "N" ]; do
		# We need to mount crypto-loop files with initial rw support
		mount -t auto -o loop,rw,encryption=AES256 "$1" "$2" && return 0
		echo -n "${RED}Mount failed, retry? [Y/n] ${NORMAL}"
		read a
	done
	return 1
}

# Unionfs
getfiledev()
{
	filedev="$(echo $MYPARAM | grep ^/media/ | tail -n 1 | sed s/\\/media\\/\\\([^\\/]\\+\\\).*/\\/dev\\/\\\1/)"
	[ -z "$filedev" ] && filedev="$(echo $MYPARAM | grep ^/dev/ | tail -n 1 | sed s/\\/dev\\/\\\([^\\/]\\+\\\).*/\\/dev\\/\\\1/)"
}

getfilepath()
{
	filepath="$(echo $MYPARAM | grep ^/media/ | sed s/\\/media\\/\\\([^\\/]\\+\\\)\\///)"
	[ -z "$filepath" ] && filepath="$(echo $MYPARAM | grep ^/dev/ | sed s/\\/dev\\/\\\([^\\/]\\+\\\)\\///)"
}

###############################################################################
#	cdrom config script
###############################################################################
# Move up with other cheats code later
checkbootparam noconfigall && NOCONFIGCD="Y" && NOCONFIGHOME="Y" && NOCONFIGCHEAT="Y"
checkbootparam noconfigcd && NOCONFIGCD="Y"
checkbootparam noconfighome && NOCONFIGHOME="Y"
checkbootparam noconfigcheat && NOCONFIGCHEAT="Y"

if [ -z "$NOCONFIGCD" ]; then
	# Check for extra shellscript on CD-Rom (/cdrom/${FLL_IMAGE_DIR}/${FLL_DISTRO_NAME}.sh)
	MYCONFIG="$(ls -1 /cdrom/${FLL_IMAGE_DIR}/ | grep -i "^${FLL_DISTRO_NAME}\\.sh$" 2>/dev/null)"
	if [ -n "$MYCONFIG" -a -f "$MYCONFIG" -a -z "$NOCONFIGCD" ]; then
		echo ""
		echo " ${GREEN}${FLL_DISTRO_NAME} Configuration file found on CD, executing ${MAGENTA}$MYCONFIG${GREEN}.${NORMAL}"
		echo "6" > /proc/sys/kernel/printk
		. "$MYCONFIG" /cdrom/${FLL_IMAGE_DIR} || true
		echo "0" > /proc/sys/kernel/printk
	fi
fi

###############################################################################
#	persistent /home
###############################################################################
# Check for persistent homedir option and eventually mount /home from there,
# or use a loopback file.
HOMEDIR="$(getbootparam home)"
MYHOMEDEVICE=""
MYHOMEMOUNTPOINT=""
MYHOMEDIR=""
if [ -n "$HOMEDIR" ]; then
	case "$HOMEDIR" in
		/dev/*)
			MYHOMEDEVICE="${HOMEDIR##/dev/}"
			MYHOMEDEVICE="/dev/${MYHOMEDEVICE%%/*}"
			MYHOMEMOUNTPOINT=$(grep $MYHOMEDEVICE /proc/mounts | cut -d' ' -f2)
			[ -z "$MYHOMEMOUNTPOINT" ] && MYHOMEMOUNTPOINT="/media/${MYHOMEDEVICE##/dev/}"
			MYHOMEDIR="/media/${HOMEDIR##/dev/}"
			;;
		/media/*)
			MYHOMEDEVICE="${HOMEDIR##/media/}"
			MYHOMEDEVICE="/dev/${MYHOMEDEVICE%%/*}"
			MYHOMEMOUNTPOINT=$(grep $MYHOMEDEVICE /proc/mounts | cut -d' ' -f2)
			[ -z "$MYHOMEMOUNTPOINT" ] && MYHOMEMOUNTPOINT="/media/${MYHOMEDEVICE##/dev/}"
			MYHOMEDIR="$HOMEDIR"
			;;
		[Aa][Uu][Tt][Oo]|[Ss][Cc][Aa][Nn]|[Ff][Ii][Nn][Dd])
			MYHOMEDIR="$(findfile $FLL_PERSISTENT_HOME)"
			MYHOMEDEVICE="${MYHOMEDIR##/media/}"
			MYHOMEDEVICE="/dev/${MYHOMEDEVICE%%/*}"
			MYHOMEMOUNTPOINT=$(grep $MYHOMEDEVICE /proc/mounts | cut -d' ' -f2)
			[ -z "$MYHOMEMOUNTPOINT" ] && MYHOMEMOUNTPOINT="/media/${MYHOMEDEVICE##/dev/}"
			;;
		*)
			echo "${CRE}${RED}Invalid ${CYAN}home=${RED} option '$HOMEDIR' specified (must start with /dev/ or /media/ or 'scan').${NORMAL}"
			echo "${CRE}${RED}Option ignored.${NORMAL}"
			;;
	esac
fi

if [ -n "$MYHOMEDIR" ]; then
	if trymount "$MYHOMEDEVICE" "$MYHOMEMOUNTPOINT"; then
		[ -f "$MYHOMEMOUNTPOINT/$FLL_PERSISTENT_HOME" ] && MYHOMEDIR="$MYHOMEMOUNTPOINT/$FLL_PERSISTENT_HOME"
		while read device mountpoint fs relax; do
			case "$mountpoint" in
				*$MYHOMEMOUNTPOINT*)
					case "$fs" in 
						*[Nn][Tt][Ff][Ss]*)
							umount "$MYHOMEMOUNTPOINT"; echo " ${RED}ERROR: WON'T MOUNT NTFS FILESYSTEM ON $MYHOMEDEVICE READ/WRITE!"
							break
							;;
						*[Ff][Aa][Tt]*)
							# Note: This currently won't work with encrypted partitions
							mount -o remount,rw,uid=${FLL_LIVE_USER},gid=$(getent passwd "$FLL_LIVE_USER" | cut -d\: -f 4),umask=002,shortname=mixed,quiet "$MYHOMEDEVICE" "$MYHOMEMOUNTPOINT"
							if [ ! -f "$MYHOMEDIR" ]; then
								echo " ${RED}WARNING: FAT32 is not a good filesystem option for /home/${FLL_LIVE_USER} (missing socket/symlink support).${NORMAL}"
								echo " ${RED}WARNING: Better use an ext2 loopback file on this device, and boot with home=$MYHOMEDEVICE/$FLL_PERSISTENT_HOME.${NORMAL}"
							fi
						;;
					esac
					if mount -o remount,rw "$MYHOMEMOUNTPOINT"; then
						echo -n " ${GREEN}Mounting ${YELLOW}$MYHOMEDIR${GREEN} as ${YELLOW}/home/${FLL_LIVE_USER}${GREEN}... "
						if [ -f "$MYHOMEDIR" ]; then
							# It's a loopback file, mount it over the /home/${FLL_LIVE_USER} directory
							trymount "$MYHOMEDIR" /home/${FLL_LIVE_USER}
							RC="$?"
							[ "$RC" = "0" ] && ERROR="$(mount -o remount,rw /home/${FLL_LIVE_USER} 2>&1)"
							RC="$?"
						else
							# Do a --bind mount
							ERROR="$(mount --bind "$MYHOMEDIR" /home/${FLL_LIVE_USER} 2>&1)"
							RC="$?"
						fi
						[ "$RC" = "0" ] && echo "${GREEN}/home/${FLL_LIVE_USER} mounted OK.${NORMAL}" || { echo "${RED}FAILED."; echo "$ERROR${NORMAL}"; }
					fi
					break
					;;
			esac
		done <<EOT
$(cat /proc/mounts)
EOT
	fi
fi

###############################################################################
#	persistent configuration
###############################################################################
if [ -z "$NOCONFIGCHEAT" ]; then
	# Check for configuration floppy add-on if not running from HD
	if [ -n "$MYCONF" ]; then
		FOUND_CONFIG=""
		if [ -n "$MYCONFDIR" ]; then
			case "$MYCONFDIR" in
				/dev/*)
					MYCONFDEVICE="${MYCONFDIR##/dev/}"
					MYCONFDEVICE="/dev/${MYCONFDEVICE%%/*}"
					MYCONFMOUNTPOINT="/media/${MYCONFDEVICE##/dev/}"
					MYCONFDIR="/media/${MYCONFDIR##/dev/}"
					;;
				/media/*)
					MYCONFDEVICE="${MYCONFDIR##/media/}"
					MYCONFDEVICE="/dev/${MYCONFDEVICE%%/*}"
					MYCONFMOUNTPOINT="/media/${MYCONFDEVICE##/dev/}"
					;;
				[Aa][Uu][Tt][Oo]|[Ss][Cc][Aa][Nn]|[Ff][Ii][Nn][Dd])
					MYCONFDIR="$(findfile ${FLL_DISTRO_NAME}.sh)"
					if [ -n "$MYCONFDIR" ]; then
						MYCONFDEVICE="${MYCONFDIR##/media/}"
						MYCONFDEVICE="/dev/${MYCONFDEVICE%%/*}"
						MYCONFMOUNTPOINT="/media/${MYCONFDEVICE##/dev/}"
						MYCONFDIR="${MYCONFMOUNTPOINT}"
					else
						FOUND_CONFIG="none"
					fi
					;;
				*)
					echo "${CRE}${RED}Invalid configdir '$MYCONFDIR' specified (must start with /dev/ or /media/ or 'scan').${NORMAL}"
					echo "${CRE}${RED}Option ignored.${NORMAL}"
					FOUND_CONFIG="invalid"
					;;
			esac
		else
			MYCONFDEVICE="/dev/fd0"
			MYCONFMOUNTPOINT="/media/floppy0"
			MYCONFDIR="/media/floppy0"
		fi

		if [ -z "$FOUND_CONFIG" ]; then
			echo -n "${CRE}${BLUE}Checking ${MAGENTA}${MYCONFDIR}${BLUE} for ${FLL_DISTRO_NAME} configuration files...${NORMAL}"
			if trymount "$MYCONFDEVICE" "$MYCONFMOUNTPOINT"; then
				MYCONFIG="$(ls -1d $MYCONFDIR/[Kk][Nn][Oo][Pp][Pp][Ii][Xx].[Ss][Hh] 2>/dev/null)"
				[ -z "$MYCONFIG" ] && MYCONFIG="$(ls -1d $MYCONFDIR/[Kk][Aa][Nn][Oo][Tt][Ii][Xx].[Ss][Hh] 2>/dev/null)"
				if [ -n "$MYCONFIG" -a -f "$MYCONFIG" ]; then
					echo ""
					FOUND_CONFIG="yes"
					echo " ${GREEN}Found, now executing ${MAGENTA}$MYCONFIG${GREEN}.${NORMAL}"
					echo "6" > /proc/sys/kernel/printk
					. "$MYCONFIG" "$MYCONFDIR" || true
					echo "0" > /proc/sys/kernel/printk
				fi
				umount "$MYCONFMOUNTPOINT" 2>/dev/null
			fi
		fi
		[ -n "$FOUND_CONFIG" ] || echo " ${BLUE}Not present.${NORMAL}"
	fi
fi

# ${FLL_DISTRO_NAME}.sh
if [ -z "$NOCONFIGHOME" -a -f /home/${FLL_LIVE_USER}/.${FLL_DISTRO_NAME}.sh ]; then
	MYCONFIG="$(ls -1d /home/${FLL_LIVE_USER}/.${FLL_DISTRO_NAME}.sh 2>/dev/null)"
	echo " ${GREEN}Found, now executing ${MAGENTA}$MYCONFIG${GREEN}.${NORMAL}"
	echo "6" > /proc/sys/kernel/printk
	. "$MYCONFIG" "/home/${FLL_LIVE_USER}" || true
	echo "0" > /proc/sys/kernel/printk	
fi

###############################################################################
# power management
###############################################################################
if [ -d /proc/acpi ]; then
	# ACPI
	if checkbootparam "noacpi"; then
		echo " ${BLUE}Skipping ACPI Bios detection as requested on boot commandline.${NORMAL}"
	else
		fuser -k /proc/acpi/event >/dev/null 2>&1
		echo " ${GREEN}ACPI Bios found, activating ${YELLOW}acpid${GREEN}.${NORMAL}"
		start_service acpid >/dev/null
	fi
else
	# APM
	if checkbootparam "noapm"; then
		echo " ${BLUE}Skipping APM Bios detection as requested on boot commandline.${NORMAL}"
	else
		if modprobe apm power_off=1 >/dev/null 2>&1; then
				echo " ${GREEN}APM Bios found, activating ${YELLOW}apmd${GREEN}.${NORMAL}"
				start_service apmd >/dev/null
		fi
	fi
fi

###############################################################################
# enable dbus & hald
###############################################################################
start_service dbus >/dev/null

###############################################################################
# powernow detection
###############################################################################
if ! checkbootparam "nocpufreq" || ! checkbootparam "nopowernow"; then
	CPUFREQ=
	CPUSERV=
	# cpufreq detection from ubuntu powernowd, exports `CPUFREQ' on successful detection
	if [ -f /usr/share/initscripts-sidux-live/cpufreq-detect ]; then
		. /usr/share/initscripts-sidux-live/cpufreq-detect
	fi
	# start power management service
	if [ -n "$CPUFREQ" ]; then
		if modprobe "$CPUFREQ" 2>/dev/null; then
			echo -n " ${GREEN}Activating ${YELLOW}${CPUFREQ}${GREEN} CPUfreq management:${NORMAL}"
			# start power management, powersaved is given preference
			if start_service powersaved >/dev/null; then
				CPUSERV=powersaved
			elif start_service powernowd >/dev/null; then
				CPUSERV=powernowd
			else
				echo " ${RED}Failed!${NORMAL}"
			fi
			# announce the service
			if [ -n "$CPUSERV" ]; then
				echo " ${MAGENTA}${CPUSERV}${GREEN}.${NORMAL}"
				# add service to hwsetup service list
				if ! grep -q ^$CPUSERV "$HWSETUP_SERVICES" 2>/dev/null; then
					echo $CPUSERV >>"$HWSETUP_SERVICES"
				fi
			fi
		fi
	fi
else
	echo "${BLUE}Skipping CPUfreq detection as requested on boot commandline.${NORMAL}"
fi

# MS MM keyboard add-on
# fix
setkeycodes e001 126 >/dev/null 2>&1
setkeycodes e059 127 >/dev/null 2>&1
# fn keys
setkeycodes e03b 59 >/dev/null 2>&1
setkeycodes e008 60 >/dev/null 2>&1
setkeycodes e007 61 >/dev/null 2>&1
setkeycodes e03e 62 >/dev/null 2>&1
setkeycodes e03f 63 >/dev/null 2>&1
setkeycodes e040 64 >/dev/null 2>&1
setkeycodes e041 65 >/dev/null 2>&1
setkeycodes e042 66 >/dev/null 2>&1
setkeycodes e043 67 >/dev/null 2>&1
setkeycodes e023 68 >/dev/null 2>&1
setkeycodes e057 87 >/dev/null 2>&1
setkeycodes e058 88 >/dev/null 2>&1

# enable hotkeys
start_service hotkey-setup >/dev/null 2>&1

update_progress 100

if checkbootparam "splash"; then
	sleep 1
	[ -p /etc/splashy/splashy.fifo ] && (echo exit > /etc/splashy/splashy.fifo) &
	rm -f /etc/splashy/splashy.fifo
	sleep 1
fi

echo "6" > /proc/sys/kernel/printk

# Re-enable signals
trap 2 3 11

exit 0

